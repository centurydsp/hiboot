// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import context "github.com/kataras/iris/context"
import mock "github.com/stretchr/testify/mock"
import websocket "github.com/kataras/iris/websocket"

// Connection is an autogenerated mock type for the Connection type
type Connection struct {
	mock.Mock
}

// Context provides a mock function with given fields:
func (_m *Connection) Context() context.Context {
	ret := _m.Called()

	var r0 context.Context
	if rf, ok := ret.Get(0).(func() context.Context); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	return r0
}

// Disconnect provides a mock function with given fields:
func (_m *Connection) Disconnect() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Emit provides a mock function with given fields: _a0, _a1
func (_m *Connection) Emit(_a0 string, _a1 interface{}) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EmitMessage provides a mock function with given fields: _a0
func (_m *Connection) EmitMessage(_a0 []byte) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Err provides a mock function with given fields:
func (_m *Connection) Err() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FireOnError provides a mock function with given fields: err
func (_m *Connection) FireOnError(err error) {
	_m.Called(err)
}

// GetValue provides a mock function with given fields: key
func (_m *Connection) GetValue(key string) interface{} {
	ret := _m.Called(key)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string) interface{}); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// GetValueArrString provides a mock function with given fields: key
func (_m *Connection) GetValueArrString(key string) []string {
	ret := _m.Called(key)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// GetValueInt provides a mock function with given fields: key
func (_m *Connection) GetValueInt(key string) int {
	ret := _m.Called(key)

	var r0 int
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetValueString provides a mock function with given fields: key
func (_m *Connection) GetValueString(key string) string {
	ret := _m.Called(key)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ID provides a mock function with given fields:
func (_m *Connection) ID() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// IsJoined provides a mock function with given fields: roomName
func (_m *Connection) IsJoined(roomName string) bool {
	ret := _m.Called(roomName)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(roomName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Join provides a mock function with given fields: _a0
func (_m *Connection) Join(_a0 string) {
	_m.Called(_a0)
}

// Leave provides a mock function with given fields: _a0
func (_m *Connection) Leave(_a0 string) bool {
	ret := _m.Called(_a0)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// On provides a mock function with given fields: _a0, _a1
func (_m *Connection) On(_a0 string, _a1 websocket.MessageFunc) {
	_m.Called(_a0, _a1)
}

// OnDisconnect provides a mock function with given fields: _a0
func (_m *Connection) OnDisconnect(_a0 websocket.DisconnectFunc) {
	_m.Called(_a0)
}

// OnError provides a mock function with given fields: _a0
func (_m *Connection) OnError(_a0 websocket.ErrorFunc) {
	_m.Called(_a0)
}

// OnLeave provides a mock function with given fields: roomLeaveCb
func (_m *Connection) OnLeave(roomLeaveCb websocket.LeaveRoomFunc) {
	_m.Called(roomLeaveCb)
}

// OnMessage provides a mock function with given fields: _a0
func (_m *Connection) OnMessage(_a0 websocket.NativeMessageFunc) {
	_m.Called(_a0)
}

// OnPing provides a mock function with given fields: _a0
func (_m *Connection) OnPing(_a0 websocket.PingFunc) {
	_m.Called(_a0)
}

// OnPong provides a mock function with given fields: _a0
func (_m *Connection) OnPong(_a0 websocket.PongFunc) {
	_m.Called(_a0)
}

// Server provides a mock function with given fields:
func (_m *Connection) Server() *websocket.Server {
	ret := _m.Called()

	var r0 *websocket.Server
	if rf, ok := ret.Get(0).(func() *websocket.Server); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*websocket.Server)
		}
	}

	return r0
}

// SetValue provides a mock function with given fields: key, value
func (_m *Connection) SetValue(key string, value interface{}) {
	_m.Called(key, value)
}

// To provides a mock function with given fields: _a0
func (_m *Connection) To(_a0 string) websocket.Emitter {
	ret := _m.Called(_a0)

	var r0 websocket.Emitter
	if rf, ok := ret.Get(0).(func(string) websocket.Emitter); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(websocket.Emitter)
		}
	}

	return r0
}

// Wait provides a mock function with given fields:
func (_m *Connection) Wait() {
	_m.Called()
}

// Write provides a mock function with given fields: websocketMessageType, data
func (_m *Connection) Write(websocketMessageType int, data []byte) error {
	ret := _m.Called(websocketMessageType, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, []byte) error); ok {
		r0 = rf(websocketMessageType, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
